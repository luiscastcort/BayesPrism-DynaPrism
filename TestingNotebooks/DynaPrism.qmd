---
title: "DynaPrism"
format: html
editor: visual
---

# 0. Environment Set-Up

```{r}
#| label: bp-libraries
library(snowfall)
library(gplots)
library(BiocParallel)
library(scran)
library(stats)
library(utils)
library(NMF)
library(Matrix)
```

```{r}
#| label: libraries
library(SingleCellExperiment)
library(ggalign)
library(ggplot2)

library(RColorBrewer)
library(colorspace)
library(viridis)

library(tidyverse)
```


```{r}
#| label: bp-functions
source("../BayesPrism/R/classes.R")
source("../BayesPrism/R/new_prism.R")
source("../BayesPrism/R/run_prism.R")
source("../BayesPrism/R/run_gibbs.R")
source("../BayesPrism/R/JointPost_functions.R")
source("../BayesPrism/R/update_reference.R")
source("../BayesPrism/R/optim_functions_MAP.R")
```

```{r}
#| label: functions
source("../R/Omega_tensor.R")
source("../R/eval_functions.R")
source("../R/plot_functions.R")
```

```{r}
#| label: global_variables
data_dir <- "../data/"
dir.exists(data_dir)
```

# 1. Loading Data
```{r}
#| label: blk_load
#| output: false
#| warning: false
blk <- DeconvoBuddies::fetch_deconvo_data("rse_gene")
```

```{r}
#| label: load_qc
load(paste0(data_dir, "NotebookRData/DynaPrism/", "sce.rdata"))
```

Getting lists of cell types and cell states.

```{r}
#| label: cell_lists
sce$cellType_hc <- droplevels(sce$cellType_hc)
sce$cellType_broad_hc <- droplevels(sce$cellType_broad_hc)
cell_types <- unique(as.vector(sce$cellType_broad_hc))
cell_states <- unique(as.vector(sce$cellType_hc))

type_to_state <- lapply(cell_types,function(t)unique(as.vector(sce$cellType_hc[sce$cellType_broad_hc==t])))
names(type_to_state) <- cell_types

state_to_type <- stack(type_to_state)
colnames(state_to_type) <- c("cell_state", "cell_type")

```

Color dictionaries for graphs

```{r}
#| label: color_dicts
type_colors <- c(
  Inhib = "#369acc", 
  Oligo = "#f8e16f", 
  OPC = "#6c584c", 
  Excit = "#95cf92", 
  Astro = "#9656a2", 
  EndoMural = "#f4895f", 
  Micro = "#de324c"
)

#type_colors <- setNames(brewer.pal(length(type_to_state), "Set3"), names(type_to_state))

state_colors <- unlist(lapply(names(type_to_state), function(ct) {
  states <- type_to_state[[ct]]
  n <- length(states)
  base <- type_colors[ct]
  
  if (n == 1) return(setNames(base, states))
  
  pal_func <- colorRampPalette(c(
    lighten(base, 0.3), 
    base, 
    darken(base, 0.3)
  ))
  
  return(setNames(pal_func(n), states))
}))

#scales::show_col(type_colors)
#scales::show_col(state_colors)
```


# 2. Omega tensor

```{r}

```


```{r}
load(paste0(data_dir, "NotebookRData/DynaPrism/", "Omega.rdata"))
load(paste0(data_dir, "NotebookRData/DynaPrism/", "Weighted_Omega.rdata"))
gene_pressure <- apply(Omega, c(2,3), sum)
```

# 2. BayesPrism

## 2.1 New Prism

```{r}
#| label: sample_vars
br_num = "Br2720"
position = "post"
sample = paste0(br_num,"_",position)
```

```{r}
#| label: new_prism
#| eval: false
rownames(blk) <- rowData(blk)$Symbol
#blk_sample = blk[intersect(rownames(sce), rownames(blk)),blk$Sample==sample]

myPrism <- new.prism(
  reference=t(as.matrix(counts(sce))), 
  mixture=t(assay(blk)),
  input.type="count.matrix", 
  cell.type.labels = sce$cellType_broad_hc, 
  cell.state.labels = sce$cellType_hc,
  key = NULL,
  outlier.cut=0.01,
    outlier.fraction=0.1,
)
save(myPrism, file=paste0(data_dir, "NotebookRData/DynaPrism/", "myPrism.rdata"))
```

```{r}
#| label: load_new_prism
load(paste0(data_dir, "NotebookRData/DynaPrism/", "myPrism.rdata"))
```

## 2.2 Run BayesPrism

```{r}
#| label: bayesprism
#| eval: false
bp_res <- run.prism(prism = myPrism, n.cores=14)
save(bp_res, file=paste0(data_dir, "NotebookRData/DynaPrism/", "bp_res.rdata"))
```

```{r}
#| label: load_bp_res
load(paste0(data_dir, "NotebookRData/DynaPrism/", "bp_res.rdata"))
```

# 3. DynaPrism Functions

## 3.1 Classes

```{r}
#| label: gibbsSampler_class
#' An S4 class to represent the input, X, phi; alpha and controls of Gibbs sampling 
#'
#' @slot phi an array of dimension K*G to denote reference matrix
#' @slot X a matrix of dimension N*G to denote bulk matrix
#' @slot theta a matrix of dimension K*N to denote the cell type fraction in each bulk
#' @slot alpha a numeric value to denote the symmetric Dirichlet prior, fixed to 1E-8 
#' @slot gibbs.control a list containing parameters of the Gibbs sampler
setClass("gibbsSamplerOmega",
         slots = c(
           reference = "reference",
           X = "matrix",
           Omega = "array",
           gibbs.control = "list"
         ),
         prototype = list(
           reference = NULL,
           X = matrix(),
           gibbs.control = list(chain.length = NULL,
           					    burn.in = NULL,
           					    thinning = NULL,
           					    n.cores = NULL,
           					    seed = NULL,
           					    alpha = NULL, 
           					    beta = NULL)
         ),
         validity = function(object){
         	errors <- character()
  			
  			if(is(object@reference, "refPhi"))
  				ref.gene <- colnames(object@reference@phi)
  			if(is(object@reference, "refTumor"))
  				ref.gene <- colnames(object@reference@psi_mal)
  			
  			if(!identical(ref.gene, colnames(object@X))){
  				msg <- paste("Gene names do not match")
  				errors <- c(errors, msg)
  			}
  			  											
         	if (length(errors) == 0) TRUE else errors
         }
)
```

```{r}
#' An S4 class to represent the output of run.prism
#'
#' @slot input.initial.cellState an S4 object of class gibbsSampler 
#'		to store the input of initial Gibbs sampling over cell states 
#' @slot posterior.initial.cellState an S4 object of class jointPost 
#'		to store the results of initial Gibbs sampling over cell states
#' @slot posterior.initial.cellType an S4 object of class jointPost 
#'		to store the results over cell types merged from posterior.initial.cellState
#' @slot reference.update an S4 object of class reference 
#'		to store the updated reference
#' @slot posterior.theta_f matrix to represent the cell type fraction from the final Gibbs sampling
#' @slot control_param a list to store all 
#'
#' @export
setClass("BayesPrismOmega",
         slots = c(
           prism = "prism",
           Omega = "array",
           posterior.initial.cellState = "jointPost",
           posterior.initial.cellType = "jointPost",
           reference.update = "reference",
           posterior.theta_f = "theta_f",
           control_param = "list"
         ),
         prototype = list(
           prism = new("prism"),
           posterior.initial.cellState = new("jointPost"),
           posterior.initial.cellType = new("jointPost"),
           reference.update = NULL,
           posterior.theta_f = NULL,
           control_param = list(gibbs.control = list(chain.length = NULL,
           					    					  burn.in = NULL,
           					    					  thinning = NULL,
           					    					  n.cores = NULL,
           					    					  seed = NULL,
           					    					  alpha=NULL,
           					    					  beta = NULL),
					  				opt.control = list(trace = NULL, 
					  								    maxit = NULL,
					  								    optimizer = NA_character_, 
					  								    n.cores = NULL),
					  				map = list(),
					  				key = NA_character_,
					  				update.gibbs = logical())
         )
)
```

## 3.2 Run Prism Functions

```{r}
#| label: valid.gibbs.control_function
#' function to validate gibbs.control
#' @param control a named list of parameters required to control optimization  
valid.gibbs.control.Omega <- function(control){
	ctrl <- list(chain.length=1000, burn.in=500, thinning=2, n.cores=1, seed=123, alpha=1, beta = 0.4)
	namc <- names(control)
	
	if (!all(namc %in% names(ctrl)))
        stop("unknown names in gibbs.control: ", namc[!(namc %in% names(ctrl))])
    ctrl[namc] <- control

	if(ctrl$alpha <0) stop("alpha needs to be positive")
  if(ctrl$beta <0) stop("beta needs to be positive")
	
	return(ctrl)
}
```


```{r}
#| label: function_run.prism

#' main function to run deconvolution using BayesPrism
#' @param n.cores number of cores to use. Default =1.
#'		If needs to set different number of cores for Gibbs sampling and optimization,
#'		supply n.cores in gibbs.control and/or opt.control
#' @param update.gibbs a logical variable to denote whether run final Gibbs sampling to update theta
#' @param gibbs.control a list containing parameters of the Gibbs sampler
#'		chain.length: length of MCMC chain. Default=1000;
#'		burn.in: length of burn in period. Default=500;
#'		thinning: retain every # of MCMC samples after the burn in period to reduce auto-correlation. Default=2;
#'		n.cores: number of cores to use. Default uses n.cores in the main argument.
#'		seed: seed number to use for repoducibility. Default = 123. set to NULL if use pseudo random.
#'		alpha: a numeric vector to represent the parameter of dirichlet distribution. Default=1. (1E-8 may yield theta=0 due to underflow. causes issue when psuedo.min=0) 
#'		beta: a numeric vector to represent the strength of the interatcion term
#' @param opt.control a list containing parameters for the optimization step:
#'		maxit: maximum number of cycles to interate. Default=100000
#'		sigma: hyper-parameter of the prior if optimizer="MAP". Default=2.
#'		optimizer a character string to denote which algorithm to use
#'			"MAP": the one used by the BayesPrism paper, with cell type-specific gamma under a log-normal prior 
#'			"MLE": the new algorithm that models a single gamma across cell types. Useful when some cell types are low in Z_k, e.g. spatial data
#'	 		default to "MAP"
#' @export
run.prism.Omega <- function(prism,
                            Omega,
                            n.cores=1,
                            update.gibbs=TRUE,
                            gibbs.control=list(),
                            opt.control=list()
                            ){
	
	if(! "n.cores" %in% names(gibbs.control)) gibbs.control$n.cores <- n.cores
	if(! "n.cores" %in% names(opt.control)) opt.control$n.cores <- n.cores
	stopifnot(is.logical(update.gibbs) & length(update.gibbs)==1)
	stopifnot(is.numeric(n.cores) & length(n.cores)==1)
	
	opt.control <- valid.opt.control(opt.control)
	gibbs.control <- valid.gibbs.control.Omega(gibbs.control)
	
	if(prism@phi_cellState@pseudo.min==0) 
		gibbs.control$alpha <- max(1, gibbs.control$alpha)
	
	#write mixture to disk and load each X_n to the corresponding node to save memory
	tmp.dir <- tempdir(check=TRUE)
	for(n in 1:nrow(prism@mixture)) {
		X_n <- prism@mixture[n,]
		file.name <- paste(tmp.dir, "/mixture_",n,".rdata",sep="")
		save(X_n, file= file.name)
	}
			
	#sampling cell states (cs)
	gibbsSampler.ini.cs <- new("gibbsSamplerOmega",
								reference = prism@phi_cellState,
								X = prism@mixture,
								Omega = Omega,
								gibbs.control = gibbs.control)

	jointPost.ini.cs <- run.gibbs.Omega(gibbsSampler.ini.cs, Omega,
								  final=FALSE)

	#merge over cell states to get cell type (ct) info
	jointPost.ini.ct <- mergeK(jointPost.obj = jointPost.ini.cs, 
					   		   			 map = prism@map)

	if(!update.gibbs) #only do initial Gibbs sampling
		bp.obj <- new("BayesPrismOmega",
		              prism = prism,
		              Omega = Omega,
		              posterior.initial.cellState = jointPost.ini.cs,
		              posterior.initial.cellType = jointPost.ini.ct,
		              control_param = list(gibbs.control = gibbs.control, 
		                                   opt.control = opt.control,
		                                   update.gibbs = update.gibbs)
		              )
	else{
		#contruct the new gibbsSampler object with updated reference
		psi <- updateReference (Z = jointPost.ini.ct@Z,
								phi_prime = prism@phi_cellType,
								map = prism@map,
								key = prism@key,
								opt.control = opt.control)
	
		gibbsSampler.update <- new("gibbsSampler",
									reference = psi,
									X = prism@mixture,
									gibbs.control = gibbs.control)
		
		theta_f <- run.gibbs(gibbsSampler.update, 
							 final=TRUE)
		
		bp.obj <- new("BayesPrismOmega",
		              prism = prism,
		              Omega = Omega,
		              posterior.initial.cellState = jointPost.ini.cs,
		              posterior.initial.cellType = jointPost.ini.ct,
		              reference.update = psi,
		              posterior.theta_f = theta_f,
		              control_param = list(gibbs.control = gibbs.control, 
		                                   opt.control = opt.control,
		                                   update.gibbs = update.gibbs)
         			 )
	}
	
	unlink(tmp.dir, recursive = TRUE)
	
	return(bp.obj) 		
}
```

## 3.3 Run Gibbs functions

```{r}
#‘ function used to estimate run time of Gibbs sampling (print to console)
#' @param gibbsSampler.obj a gibbsSampler object
#' @param final a logical variable denote whether report only updated theta_f (final =TRUE)
#' @param chain.length length of MCMC chain used to simulate. Default=50.
estimate.gibbs.time.Omega <- function(gibbsSampler.obj,
								final, 
								chain.length=50){
	
	ref <- gibbsSampler.obj@reference
	X <- gibbsSampler.obj@X
	gibbs.control <- gibbsSampler.obj@gibbs.control
	
	ptm <- proc.time()
	
	if(!final){
		#initial Gibbs
		sample.Z.theta_n.Omega (X_n = X[1,], 
								  phi = ref@phi, 
								  alpha = gibbs.control$alpha,
								  Omega = gibbsSampler.obj@Omega,
								  beta = gibbs.control$beta,
								  gibbs.idx = get.gibbs.idx(
				     		 	  	list(chain.length = chain.length, 
				     					 burn.in = chain.length*gibbs.control$burn.in/gibbs.control$chain.length,
				     					 thinning = gibbs.control$thinning)
				     		 	  )
						   )
	}
	else{
		#updated Gibbs
		if(is(ref,"refPhi")){
			sample.theta_n (X_n = X[1,], 
							phi = ref@phi, 
							alpha = gibbs.control$alpha,
							gibbs.idx = get.gibbs.idx(
				     			list(chain.length = chain.length, 
				     				burn.in = chain.length*gibbs.control$burn.in/gibbs.control$chain.length,
				     				thinning = gibbs.control$thinning)
				     		 	 )
				    			)
		}
		if(is(ref,"refTumor")){
		 	phi_1 <- rbind(ref@psi_mal[1,], ref@psi_env)
			nonzero.idx <- apply(phi_1,2,max)>0
		 	sample.theta_n (X_n = X[1,nonzero.idx, drop=F], 
							phi = phi_1[, nonzero.idx, drop=F], 
							alpha = gibbs.control$alpha,
							gibbs.idx = get.gibbs.idx(
				     			list(chain.length = chain.length, 
				     				 burn.in = chain.length*gibbs.control$burn.in/gibbs.control$chain.length,
				     				 thinning = gibbs.control$thinning)
				     		 	)
				    			)	
		}	
	}
	
	total.time <- proc.time() - ptm
	total.time <- as.numeric(total.time["elapsed"])
	
	# seems to underestimate when transferring data comsumes large amount of time (spatial data)
	estimated.time <- gibbs.control $chain.length / chain.length * total.time * ceiling(nrow(X) / gibbs.control$n.cores) *2 		
	current.time <- Sys.time()
	
	cat("Current time: ", as.character(current.time), "\n")
	cat("Estimated time to complete: ", my_seconds_to_period(estimated.time), "\n")
	cat("Estimated finishing time: ", as.character(current.time + estimated.time), "\n")

}
```

```{r}
#| label: function_run.gibbs

#' function to run Gibbs sampling 
#'
#' @param gibbsSampler.obj, a gibbsSampler object
#' @param final a logical variable denote whether report only updated theta_f (final=TRUE)
#' @param if.estimate a logical variable denote whether estimate the run time. Default=TRUE
#' @import snowfall
#' @return a gibbsSampler object with Z and theta entries, if final=FALSE,  or theta_f matrix if final=TRUE
run.gibbs.Omega <- function(gibbsSampler.obj, 
                            Omega,
                            final,
                            if.estimate=TRUE,
                            compute.elbo=FALSE
                            ){
	
	if(final) cat("Run Gibbs sampling using updated reference ... \n")
	else cat("Run Gibbs sampling... \n")

	if(if.estimate)
		estimate.gibbs.time.Omega(gibbsSampler.obj = gibbsSampler.obj, 
							final = final)
	
	if(is(gibbsSampler.obj@reference,"refPhi")) {
		if(!final) return(run.gibbs.refPhi.ini.Omega(gibbsSampler.obj = gibbsSampler.obj, 
		                                             Omega = Omega,
		                                             compute.elbo = compute.elbo))
		else return(run.gibbs.refPhi.final.Omega(gibbsSampler.obj = gibbsSampler.obj, 
		                                         Omega = Omega,
		                                         compute.elbo = compute.elbo))
	}
	if(is(gibbsSampler.obj@reference,"refTumor")) {
		return(run.gibbs.refTumor(gibbsSampler.obj = gibbsSampler.obj))	
	}
}
```

```{r}
#| label: function_run.gibbs.refPhi.ini

#' function to run initial Gibbs sampling if reference is of the class refPhi
#'
#' @param gibbsSampler.obj, a gibbsSampler object
#' @import snowfall
#' @return a jointPost object with Z and theta entries 
run.gibbs.refPhi.ini.Omega <- function(gibbsSampler.obj,
                                       Omega,
                                       compute.elbo){
	
	phi <- gibbsSampler.obj@reference@phi
	X <- gibbsSampler.obj@X
	gibbs.control <- gibbsSampler.obj@gibbs.control
	alpha <- gibbs.control$alpha
	beta <- gibbs.control$beta
	
	gibbs.idx <- get.gibbs.idx(gibbs.control)
	seed <- gibbs.control$seed

	##### LOOK INTO THESE
	#sample.Z.theta_n.Omega <- DynaPrism:::sample.Z.theta_n.Omega
	#rdirichlet <- BayesPrism:::rdirichlet
	
	cat("Start run... \n")
	
	if(gibbs.control$n.cores>1){	
		#parallel using snowfall	
		sfInit(parallel = TRUE, cpus = gibbs.control$n.cores, type = "SOCK" )
					
		cpu.fun <- function(n) {
			if(!is.null(seed)) set.seed(seed)
			#load nth mixture from disk
			file.name.X_n <- paste(tmp.dir, "/mixture_",n,".rdata",sep="")
			load(file.name.X_n)
			
			sample.Z.theta_n.Omega (X_n = X_n, 
							  phi = phi, 
							  alpha = alpha, 
							  Omega = Omega,
							  beta = beta,
							  gibbs.idx = gibbs.idx, 
							  compute.elbo = compute.elbo)		
		}
		tmp.dir <- tempdir(check=TRUE)
		sfExport("phi", "alpha", "Omega", "beta", "gibbs.idx", "seed", 
				 	"compute.elbo", "sample.Z.theta_n.Omega","rdirichlet","tmp.dir")
		environment(cpu.fun) <- globalenv()
		gibbs.list <- sfLapply( 1:nrow(X), cpu.fun)
		sfStop()
	}
	else{
		#single thread
		cpu.fun <- function(n) {
				if(!is.null(seed)) set.seed(seed)
				cat(n," ")
				sample.Z.theta_n.Omega (X_n = X[n,], 
				                        phi = phi,
				                        alpha = alpha, 
				                        Omega = Omega,
				                        alpha = alpha,
				                        gibbs.idx = gibbs.idx,
				                        compute.elbo = compute.elbo)
		}
		gibbs.list <- lapply( 1:nrow(X), cpu.fun)
		cat("\n")
	}
	
	jointPost <- newJointPost(bulkID = rownames(X),
							  geneID = colnames(X), 
							  cellType = rownames(phi),
							  gibbs.list = gibbs.list )
	return(jointPost)
}
```

```{r}
#| label: function_run.gibbs.refPhi.final

#' function to run final sampling if reference is of the class refPhi
#'
#' @param gibbsSampler.obj, a gibbsSampler object
#' @import snowfall
#' @return a theta_f matrix 
run.gibbs.refPhi.final.Omega <- function(gibbsSampler.obj,
                                   Omega,
                                   compute.elbo){
	
	phi <- gibbsSampler.obj@reference@phi
	X <- gibbsSampler.obj@X
	gibbs.control <- gibbsSampler.obj@gibbs.control
	alpha <- gibbs.control$alpha
	beta <- gibbs.control$beta
	
	gibbs.idx <- get.gibbs.idx(gibbs.control)
	seed <- gibbs.control$seed

	##### LOOK INTO THESE
	#sample.theta_n.Omega <- DynaPrism:::sample.theta_n.Omega
	#rdirichlet <- BayesPrism:::rdirichlet
	
	cat("Start run... \n")
	
	if(gibbs.control$n.cores>1){	
		#parallel using snowfall	
		sfInit(parallel = TRUE, cpus = gibbs.control$n.cores, type = "SOCK" )
		
		cpu.fun <- function(n) {
			if(!is.null(seed)) set.seed(seed)
			#load nth mixture from disk
			file.name.X_n <- paste(tmp.dir, "/mixture_",n,".rdata",sep="")
			load(file.name.X_n)
			
			sample.theta_n.Omega (X_n = X_n, 
								phi = phi, 
								alpha = alpha, 
							  Omega = Omega,
							  beta = beta,
								gibbs.idx = gibbs.idx)		
		}
		tmp.dir <- tempdir(check=TRUE)
		sfExport("phi", "alpha", "gibbs.idx", "seed", 
				 "compute.elbo", "sample.theta_n","rdirichlet","tmp.dir")
		environment(cpu.fun) <- globalenv()
		gibbs.list <- sfLapply( 1:nrow(X), cpu.fun)
		sfStop() 
	}
	else{
		#single thread
		cpu.fun <- function(n) {
			if(!is.null(seed)) set.seed(seed)
			cat(n," ")
			sample.theta_n.Omega (X_n = X[n,], phi = phi, alpha = alpha,
							  Omega = Omega,
							  beta = beta, gibbs.idx = gibbs.idx)
		}
		gibbs.list <- lapply( 1:nrow(X), cpu.fun)
		cat("\n")
	}
	thetaPost <- newThetaPost (bulkID = rownames(X),
						 			   cellType = rownames(phi),
						 			   gibbs.list = gibbs.list)
	return(thetaPost)
}
```

## 3.4 Sampler functions

```{r}
#| label: function_sample.Z.theta_n

#' function to run Gibbs sampling for Z and theta on each bulk
#' @param X_n a numeric vector of reads count of the nth bulk sample
#' @param phi an array of dimension K*G to denote reference matrix
#' @param alpha a numeric value to denote the symmetric Dirichlet prior 
#' @param gibbs.idx a numeric vector to denote the index of samples to be retained from MCMC chain
#' @param compute.elbo a logical variable to denote if compute ELBO. Default=FALSE.
#' return a list containing the posterior mean of Z_n and theta_n
sample.Z.theta_n.Omega <- function(X_n, 
				        	 	 phi,
				        	 	alpha,
				        	 	Omega, 
				        	 	beta,
				        	 	gibbs.idx,
				        	 	compute.elbo=FALSE){
		
  # Setting up Omega implementatiom
	K_names <- rownames(phi) # # of Sender States
	S_names <- rownames(phi) # # of Receiver States
	G_names <- colnames(phi) # # of Genes
	G_shared_idx <- which(colnames(phi) %in% dimnames(Omega)$Gene)
	G_shared_names <- colnames(phi)[G_shared_idx]
	
	K_dim <- length(K_names)
	S_dim <- length(S_names)
	G_dim <- length(G_names)
		
	theta_n.i <- rep(1/S_dim, S_dim)
	Z_n.i <- array(NA,c(G_dim,S_dim))
	
	Z_n.sum <- array(0,c(G_dim,S_dim))
	theta_n.sum <- rep(0, S_dim)
	theta_n2.sum <- rep(0, S_dim)
	
	#variable for computing ELBO
	multinom.coef <- 0
	
	# 
	phi_mat <- as.matrix(phi)
	X_vec <- as.numeric(X_n[G_names])
	
	# Making Omega flat
	Omega_flat <- matrix(Omega[K_names, S_names, G_shared_names], nrow = S_dim, ncol = S_dim * length(G_shared_names))

	for(i in 1:max(gibbs.idx)){
	  
	  niche_pressure_vec <- as.numeric(theta_n.i %*% Omega_flat)
	  niche_pressure_mat <- matrix(niche_pressure_vec, nrow = S_dim, ncol = length(G_shared_idx))
	  
	  sd_p <- sd(niche_pressure_mat)
	  if(!is.na(sd_p) && sd_p > 0) niche_pressure_mat <- niche_pressure_mat / sd_p
	
		#sample Z for patient n
	  prob.mat <- (phi_mat * theta_n.i)
	  prob.mat[,G_shared_idx] <- prob.mat[,G_shared_idx] * exp(beta * niche_pressure_mat)

	  for (g in 1:G_dim) {
	    Z_n.i[g,] <- rmultinom(n = 1, size = X_vec[g], prob = prob.mat[, g])
	    }
		# sample theta for patient n
		Z_nk.i <- colSums(Z_n.i) #total count for each cell type
		theta_n.i <- rdirichlet(alpha = Z_nk.i + alpha)
				
		if(i %in% gibbs.idx) {
			#collect sample and compute posterior sum
			Z_n.sum <- Z_n.sum + Z_n.i
			theta_n.sum <- theta_n.sum + theta_n.i
			theta_n2.sum <- theta_n2.sum + theta_n.i^2
			
			if(compute.elbo){
				# multinom.coef.i <- sum((alpha-1) * log(theta_n.i), na.rm=TRUE) + 
								   # sum(Z_nk.i * log(theta_n.i), na.rm=TRUE) - 
								   # sum(lfactorial(Z_nk.i)) - sum(lfactorial(Z_n.i))
				multinom.coef.i <- sum(lfactorial(Z_nk.i)) - sum(lfactorial(Z_n.i))
				multinom.coef <- multinom.coef + multinom.coef.i
				
			}	
		}
		
		if((i %% 50) == 0) gc()
	}
	
	samples.size <- length(gibbs.idx)
	#gibbs.constant <- multinom.coef + z.logtheta + theta.dirichlet.alpha
	
	Z_n <- Z_n.sum / samples.size
	theta_n <- theta_n.sum / samples.size
	theta.cv_n <- sqrt(theta_n2.sum / samples.size - (theta_n^2)) / theta_n
	gibbs.constant <- multinom.coef / samples.size
		
	return(list(Z_n = Z_n, 
			    theta_n = theta_n,
			    theta.cv_n = theta.cv_n,
			    gibbs.constant = gibbs.constant))
}
```

## 3.5 Running DynaPrism

```{r}
#| label: running_dynaprism
#| eval: false
dp_res <- run.prism.Omega(prism = myPrism, Omega = Omega, n.cores=14)
save(dp_res, file=paste0(data_dir, "NotebookRData/DynaPrism/", "dp_res.rdata"))
```

```{r}
#| label: loading_dynaprism
load(paste0(data_dir, "NotebookRData/DynaPrism/", "dp_res.rdata"))
```

# 4. Bulk Library Evaluations

```{r}
#| label: lib_definition
lib_prep <- "Bulk"
lib_type <- "polyA"
```

## 4.1 Fraction estimations

### 4.1.1 Cell-State

```{r}
#| label: fracs
blk_n_meta <- as.data.frame(colData(blk)[,c("SAMPLE_ID", "Sample", "library_prep", "library_type")])

cells_per_state <- table(colData(sce)$Sample, colData(sce)$cellType_hc)
true_s_frac <- as.table((cells_per_state/rowSums(cells_per_state))[,cell_states])
bp_s_frac <- as.table(bp_res@posterior.initial.cellState@theta)[rownames(blk_n_meta),cell_states]
dp_s_frac <- as.table(dp_res@posterior.initial.cellState@theta)[rownames(blk_n_meta),cell_states]
```

```{r}
#| label: lib_s_frac
dp_s_lib <- (dp_s_frac[blk_n_meta$library_prep == lib_prep & blk_n_meta$library_type == lib_type,])
rownames(dp_s_lib) <- blk_n_meta[rownames(blk_n_meta) %in% rownames(dp_s_lib),"Sample"]

bp_s_lib <- (bp_s_frac[blk_n_meta$library_prep == lib_prep & blk_n_meta$library_type == lib_type,])
rownames(bp_s_lib) <- blk_n_meta[rownames(blk_n_meta) %in% rownames(bp_s_lib),"Sample"]

lib_s_frac_dp <- eval_frac(dp_s_lib, true_s_frac)
lib_s_frac_bp <- eval_frac(bp_s_lib, true_s_frac)
```

```{r}
#| label: s_frac_plot
true_s_frac_df <- as.data.frame(true_s_frac)
colnames(true_s_frac_df) <- c("Sample", "cell_state", "Fraction")
true_s_frac_df$SAMPLE_ID <- NA
true_s_frac_df$library_prep <- "Nuc"
true_s_frac_df$library_type <- "polyA"
true_s_frac_df$cell_state <- trimws(as.character(true_s_frac_df$cell_state))
true_s_frac_df$cell_state <- factor(true_s_frac_df$cell_state, 
                                    levels = sort(unique(true_s_frac_df$cell_state)))

bp_s_frac_df <- as.data.frame(bp_s_frac)
colnames(bp_s_frac_df) <- c("SAMPLE_ID", "cell_state", "Fraction")
bp_s_frac_df <- merge(bp_s_frac_df, 
                    blk_n_meta[, c("SAMPLE_ID", "Sample", "library_prep", "library_type")], 
                    by = "SAMPLE_ID", 
                    all.x = TRUE)
bp_s_frac_df$cell_state <- trimws(as.character(bp_s_frac_df$cell_state))
bp_s_frac_df$cell_state <- factor(bp_s_frac_df$cell_state,
                                  levels = sort(unique(bp_s_frac_df$cell_state)))

dp_s_frac_df <- as.data.frame(dp_s_frac)
colnames(dp_s_frac_df) <- c("SAMPLE_ID", "cell_state", "Fraction")
dp_s_frac_df <- merge(dp_s_frac_df, 
                    blk_n_meta[, c("SAMPLE_ID", "Sample", "library_prep", "library_type")], 
                    by = "SAMPLE_ID", 
                    all.x = TRUE)
dp_s_frac_df$cell_state <- trimws(as.character(dp_s_frac_df$cell_state))
dp_s_frac_df$cell_state <- factor(dp_s_frac_df$cell_state,
                                  levels = sort(unique(dp_s_frac_df$cell_state)))

true_s_frac_df$Source <- "snRNA-seq"
bp_s_frac_df$Source <- "BayesPrism"
dp_s_frac_df$Source <- paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ")")
combined_s_df <- rbind(bp_s_frac_df, dp_s_frac_df, true_s_frac_df)

samples <- sort(as.character(unique(combined_s_df$Sample)))[c(5:8)]
combined_s_df <- combined_s_df[combined_s_df$Sample %in% samples, ]
```

```{r}
ggplot(combined_s_df, mapping = aes(y = Fraction, x = library_prep, fill = cell_state)) +
  geom_col() +
  scale_fill_manual(values = state_colors) +
  facet_grid(Sample ~ Source + library_type, scales = "free_x", space = "free_x") +
  theme_minimal() + # Use a cleaner base theme
  theme(
    # Remove y-axis text and ticks
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    # Rotate the Sample labels (strips) on the right to be horizontal
    strip.text.y = element_text(angle = 0),
    # Rotate x-axis labels if they start to overlap
    axis.text.x = element_text(angle = 45, hjust = 1),
    # Optional: adjust the spacing between facets
    panel.spacing = unit(0.1, "lines")
  )
```

### 4.1.2 Cell-Type

```{r}
cells_per_type <- table(colData(sce)$Sample, colData(sce)$cellType_broad_hc)
true_t_frac <- as.table((cells_per_type/rowSums(cells_per_type))[, cell_types])
#bp_t_frac <- as.table(bp_res@posterior.initial.cellType@theta)[rownames(blk_n_meta), cell_types]
bp_t_frac <- as.table(bp_res@posterior.theta_f@theta)[rownames(blk_n_meta), cell_types]
#dp_t_frac <- as.table(dp_res@posterior.initial.cellType@theta)[rownames(blk_n_meta), cell_types]
dp_t_frac <- as.table(dp_res@posterior.theta_f@theta)[rownames(blk_n_meta), cell_types]

dp_t_lib <- dp_t_frac[blk_n_meta$library_prep == lib_prep & blk_n_meta$library_type == lib_type,]
rownames(dp_t_lib) <- blk_n_meta[rownames(blk_n_meta) %in% rownames(dp_t_lib),"Sample"]
bp_t_lib <- bp_t_frac[blk_n_meta$library_prep == lib_prep & blk_n_meta$library_type == lib_type,]
rownames(bp_t_lib) <- blk_n_meta[rownames(blk_n_meta) %in% rownames(bp_t_lib),"Sample"]

lib_t_frac_dp <- eval_frac(dp_t_lib, true_t_frac)
lib_t_frac_bp <- eval_frac(bp_t_lib, true_t_frac)
```

```{r}
#| label: t_frac_plot
true_t_frac_df <- as.data.frame(true_t_frac)
colnames(true_t_frac_df) <- c("Sample", "cell_type", "Fraction")
true_t_frac_df$SAMPLE_ID <- NA
true_t_frac_df$library_prep <- "Nuc"
true_t_frac_df$library_type <- "polyA"
true_t_frac_df$cell_type <- trimws(as.character(true_t_frac_df$cell_type))
true_t_frac_df$cell_type <- factor(true_t_frac_df$cell_type, 
                                    levels = sort(unique(true_t_frac_df$cell_type)))

bp_t_frac_df <- as.data.frame(bp_t_frac)
colnames(bp_t_frac_df) <- c("SAMPLE_ID", "cell_type", "Fraction")
bp_t_frac_df <- merge(bp_t_frac_df, 
                    blk_n_meta[, c("SAMPLE_ID", "Sample", "library_prep", "library_type")], 
                    by = "SAMPLE_ID", 
                    all.x = TRUE)
bp_t_frac_df$cell_type <- trimws(as.character(bp_t_frac_df$cell_type))
bp_t_frac_df$cell_type <- factor(bp_t_frac_df$cell_type,
                                  levels = sort(unique(bp_t_frac_df$cell_type)))

dp_t_frac_df <- as.data.frame(dp_t_frac)
colnames(dp_t_frac_df) <- c("SAMPLE_ID", "cell_type", "Fraction")
dp_t_frac_df <- merge(dp_t_frac_df, 
                    blk_n_meta[, c("SAMPLE_ID", "Sample", "library_prep", "library_type")], 
                    by = "SAMPLE_ID", 
                    all.x = TRUE)
dp_t_frac_df$cell_type <- trimws(as.character(dp_t_frac_df$cell_type))
dp_t_frac_df$cell_type <- factor(dp_t_frac_df$cell_type,
                                  levels = sort(unique(dp_t_frac_df$cell_type)))

true_t_frac_df$Source <- "snRNA-seq"
bp_t_frac_df$Source <- "BayesPrism"
dp_t_frac_df$Source <- paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ")")
combined_t_df <- rbind(bp_t_frac_df, dp_t_frac_df, true_t_frac_df)

samples <- sort(as.character(unique(combined_t_df$Sample)))[c(5:8)]
combined_t_df <- combined_t_df[combined_t_df$Sample %in% samples, ]
```

```{r}
ggplot(combined_t_df, mapping = aes(y = Fraction, x = library_prep, fill = cell_type)) +
  geom_col() +
  scale_fill_manual(values = type_colors) +
  facet_grid(Sample ~ Source + library_type, scales = "free_x", space = "free_x") +
  theme_minimal() + # Use a cleaner base theme
  theme(
    # Remove y-axis text and ticks
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    # Rotate the Sample labels (strips) on the right to be horizontal
    strip.text.y = element_text(angle = 0),
    # Rotate x-axis labels if they start to overlap
    axis.text.x = element_text(angle = 45, hjust = 1),
    # Optional: adjust the spacing between facets
    panel.spacing = unit(0.1, "lines")
  )
```

## 4.2 CTSE estimations

### 4.2.1 Cell-state
```{r}
#| label: true_s_exp
source("../R/eval_functions.R")
true_s_exp <- sc_exp_tensor(assay(sce, "counts"), colData(sce)$Sample, colData(sce)$cellType_hc, fun = "sum")
counts_per_state <- apply(true_s_exp, c(1,3), sum)
true_s_frac <- as.table((counts_per_state/rowSums(counts_per_state))[, cell_states])
```


```{r}
#| label: inf_s_exp
bp_s_exp <- bp_res@posterior.initial.cellState@Z
dp_s_exp <- dp_res@posterior.initial.cellState@Z
```

```{r}
#| label: state_markers
#| eval: false

bp_param <- SnowParam(workers = 14, type = "SOCK")

state_markers <- findMarkers(
    sce, 
    groups = sce$cellType_hc, 
    block = sce$Sample,
    test.type = "t",
    direction = "up",
    BPPARAM = bp_param
)

save(state_markers, file=paste0(data_dir, "NotebookRData/DynaPrism/", "state_markers.rdata"))
```

```{r}
#| label: load_state_markers
load(paste0(data_dir, "NotebookRData/DynaPrism/", "state_markers.rdata"))
```

```{r}
#| label: filter_state_markers

state_marker_list <- lapply(state_markers, function(x) {
    # Filter by FDR and logFC thresholds
    sub <- x[x$FDR < 0.05 & x$summary.logFC > 1, ]
    
    # Sort by the most specific (lowest FDR or highest logFC)
    # Sorting by logFC is usually better for 'identity' markers
    sub <- sub[order(sub$summary.logFC, decreasing = TRUE), ]
    
    # Take the top 50 (or fewer if less pass the filter)
    top_genes <- head(rownames(sub), 50)
    
    return(top_genes)
})
```

```{r}
#| label: eval_CTSE_s

lib_prep <- "Bulk"
lib_type <- "polyA"
bp_s_lib <- bp_s_exp[blk_n_meta$library_prep == lib_prep & blk_n_meta$library_type == lib_type, , ]
dimnames(bp_s_lib)[[1]] <- blk_n_meta[rownames(blk_n_meta) %in% dimnames(bp_s_lib)[[1]],"Sample"]

dp_s_lib <- dp_s_exp[blk_n_meta$library_prep == lib_prep & blk_n_meta$library_type == lib_type, , ]
dimnames(dp_s_lib)[[1]] <- blk_n_meta[rownames(blk_n_meta) %in% dimnames(dp_s_lib)[[1]],"Sample"]

source("../R/eval_functions.R")

# Run the evaluation
lib_s_CTSE_dp <- eval_CTSE(dp_s_lib, true_s_exp, markers_list = state_marker_list)
lib_s_CTSE_bp <- eval_CTSE(bp_s_lib, true_s_exp, markers_list = state_marker_list)
```

```{r}
plot_DeltaCTSE(lib_s_CTSE_dp, lib_s_CTSE_bp, 
               title = paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ") Performance Gain over BayesPrism"),
               subtitle = paste0(lib_prep, "-", lib_type, " RNA-seq library"),
               group_colors = state_colors, 
               mod_name = "DynaPrism", ori_name = "BayesPrism")


plot_ExpSpe(lib_s_CTSE_dp, lib_s_CTSE_bp, gene_pressure, 
            title = "State-Level Expression Specificity",
            subtitle = paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ") on ", lib_prep, "-", lib_type, " RNA-seq library"),
            mod_name = "DynaPrism", ori_name = "BayesPrism")
```

#### 4.2.1.1 Plain Bulk

```{r}
#| label: blk_s_exp
X <- as.matrix(myPrism@mixture)
X_cpm <- sweep(X, 1, rowSums(X), "/") * 1e6

G_names <- colnames(X)
N_names <- rownames(X)
K_names <- cell_states

blk_s_exp <- array(NA, 
                        dim = c(length(N_names), length(G_names), length(K_names)),
                        dimnames = list(N_names, G_names, K_names))

for(k in K_names) {
  blk_s_exp[,,k] <- X
}

blk_s_lib <- blk_s_exp[blk_n_meta$library_prep == lib_prep & blk_n_meta$library_type == lib_type, , ]
dimnames(blk_s_lib)[[1]] <- blk_n_meta[rownames(blk_n_meta) %in% dimnames(blk_s_lib)[[1]],"Sample"]
```

```{r}
lib_s_CTSE_blk <- eval_CTSE(blk_s_lib, true_s_exp, markers_list = state_marker_list)
```

```{r}
plot_DeltaCTSE(lib_s_CTSE_dp, lib_s_CTSE_blk, 
               title = paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ") Performance Gain over Plain Bulk"),
               subtitle = paste0(lib_prep, "-", lib_type, " RNA-seq library"),
               group_colors = state_colors, 
               mod_name = "DynaPrism", ori_name = "Plain Bulk")

plot_DeltaCTSE(lib_s_CTSE_bp, lib_s_CTSE_blk, 
               #title = paste0("BayesPrism Performance Gain"),
               subtitle = paste0(lib_prep, "-", lib_type, " RNA-seq library"),
               group_colors = state_colors, 
               mod_name = "BayesPrism", ori_name = "Plain Bulk")
```

### 4.2.2 Cell-type

```{r}
#| label: true_t_exp

true_t_exp <- sc_exp_tensor(assay(sce, "counts"), colData(sce)$Sample, colData(sce)$cellType_broad_hc, fun = "sum")
counts_per_type <- apply(true_t_exp, c(1,3), sum)
true_t_frac <- as.matrix((counts_per_type/rowSums(counts_per_type))[,cell_types])
```

```{r}
#| label: inf_t_exp
bp_t_exp <- bp_res@posterior.initial.cellType@Z
dp_t_exp <- dp_res@posterior.initial.cellType@Z
```

```{r}
#| label: type_markers
#| eval: false

bp_param <- SnowParam(workers = 14, type = "SOCK")

type_markers <- findMarkers(
    sce, 
    groups = sce$cellType_broad_hc, 
    block = sce$Sample,
    test.type = "t",
    direction = "up",
    BPPARAM = bp_param
)

save(type_markers, file=paste0(data_dir, "NotebookRData/DynaPrism/", "type_markers.rdata"))
```

```{r}
#| label: load_type_markers
load(paste0(data_dir, "NotebookRData/DynaPrism/", "type_markers.rdata"))
```

```{r}
#| label: filter_type_markers

type_marker_list <- lapply(type_markers, function(x) {
    # Filter by FDR and logFC thresholds
    sub <- x[x$FDR < 0.05 & x$summary.logFC > 1, ]
    
    # Sort by the most specific (lowest FDR or highest logFC)
    # Sorting by logFC is usually better for 'identity' markers
    sub <- sub[order(sub$summary.logFC, decreasing = TRUE), ]
    
    # Take the top 50 (or fewer if less pass the filter)
    top_genes <- head(rownames(sub), 50)
    
    return(top_genes)
})
```

```{r}
#lib_prep <- "Nuc"
#lib_type <- "RiboZeroGold"

bp_t_lib <- bp_t_exp[blk_n_meta$library_prep == lib_prep & blk_n_meta$library_type == lib_type, , ]
dimnames(bp_t_lib)[[1]] <- blk_n_meta[rownames(blk_n_meta) %in% dimnames(bp_t_lib)[[1]],"Sample"]

dp_t_lib <- dp_t_exp[blk_n_meta$library_prep == lib_prep & blk_n_meta$library_type == lib_type, , ]
dimnames(dp_t_lib)[[1]] <- blk_n_meta[rownames(blk_n_meta) %in% dimnames(dp_t_lib)[[1]],"Sample"]

# Run the evaluation
source("../R/eval_functions.R")
lib_t_CTSE_dp <- eval_CTSE(dp_t_lib, true_t_exp, markers_list = type_marker_list)
lib_t_CTSE_bp <- eval_CTSE(bp_t_lib, true_t_exp, markers_list = type_marker_list)
```

```{r}
plot_DeltaCTSE(lib_t_CTSE_dp, lib_t_CTSE_bp, 
               title = paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ") Performance Gain"),
               subtitle = paste0(lib_prep, "-", lib_type, " RNA-seq library"),
               group_colors = type_colors, 
               mod_name = "DynaPrism", ori_name = "BayesPrism")


plot_ExpSpe(lib_t_CTSE_dp, lib_t_CTSE_bp, gene_pressure, 
            title = "Type-Level Expression Specificity",
            subtitle = paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ") on ", lib_prep, "-", lib_type, " RNA-seq library"),
            mod_name = "DynaPrism", ori_name = "BayesPrism")
```

#### 4.2.2.1 Plain Bulk

```{r}
#| label: blk_t_exp
X <- as.matrix(myPrism@mixture)
X_cpm <- sweep(X, 1, rowSums(X), "/") * 1e6

G_names <- colnames(X)
N_names <- rownames(X)
K_names <- cell_types

blk_t_exp <- array(NA, 
                        dim = c(length(N_names), length(G_names), length(K_names)),
                        dimnames = list(N_names, G_names, K_names))

for(k in K_names) {
  blk_t_exp[,,k] <- X
}

blk_t_lib <- blk_t_exp[blk_n_meta$library_prep == lib_prep & blk_n_meta$library_type == lib_type, , ]
dimnames(blk_t_lib)[[1]] <- blk_n_meta[rownames(blk_n_meta) %in% dimnames(blk_t_lib)[[1]],"Sample"]
```

```{r}
lib_t_CTSE_blk <- eval_CTSE(blk_t_lib, true_t_exp, markers_list = state_marker_list)
```

```{r}
plot_DeltaCTSE(lib_t_CTSE_dp, lib_t_CTSE_blk, 
               title = paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ") Performance Gain over Plain Bulk"),
               subtitle = paste0(lib_prep, "-", lib_type, " RNA-seq library"),
               group_colors = type_colors, 
               mod_name = "DynaPrism", ori_name = "Plain Bulk")

plot_DeltaCTSE(lib_t_CTSE_bp, lib_t_CTSE_blk, 
               #title = paste0("BayesPrism Performance Gain"),
               subtitle = paste0(lib_prep, "-", lib_type, " RNA-seq library"),
               group_colors = type_colors, 
               mod_name = "BayesPrism", ori_name = "Plain Bulk")
```

#### 4.2.2.2 Fraction-Regressed Bulk

```{r}
X_lib <- X[blk_n_meta$library_prep == lib_prep & blk_n_meta$library_type == lib_type, ]
rownames(X_lib) <- blk_n_meta[blk_n_meta$library_prep == lib_prep & blk_n_meta$library_type == lib_type, "Sample"]
common_n <- intersect(rownames(X_lib), rownames(true_t_frac))

X_lib <- X_lib[common_n, ]
theta_t <- true_t_frac[common_n, ]

beta_hat_t <- solve(t(theta_t) %*% theta_t) %*% t(theta_t) %*% X_lib
X_hat_t <- theta_t %*% beta_hat_t

mu_g <- colMeans(X_lib)

# Calculate X_regress: X_observed - X_predicted + mu_g
X_regress_t <- X_lib - X_hat_t
X_regress_t <- sweep(X_regress_t, 2, mu_g, "+")
X_regress_t[X_regress_t < 0] <- 0

K_names <- colnames(theta_t)
G_names <- colnames(X_lib)
N_names <- rownames(X_lib)

rgr_t_lib <- array(NA,
                   dim = c(length(N_names), length(G_names), length(K_names)),
                   dimnames = list(N_names, G_names, K_names))

for(k in K_names) {
  rgr_t_lib[,,k] <- X_regress_t
}
```

```{r}
lib_t_CTSE_rgr <- eval_CTSE(rgr_t_lib, true_t_exp, markers_list = state_marker_list)
```

```{r}
plot_DeltaCTSE(lib_t_CTSE_rgr, lib_t_CTSE_blk, 
               #title = paste0("BayesPrism Performance Gain"),
               subtitle = paste0(lib_prep, "-", lib_type, " RNA-seq library"),
               group_colors = type_colors, 
               mod_name = "Fraction-Regressed Bulk", ori_name = "Plain Bulk")

plot_DeltaCTSE(lib_t_CTSE_dp, lib_t_CTSE_rgr, 
               title = paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ") Performance Gain over Fraction-Regressed Bulk"),
               subtitle = paste0(lib_prep, "-", lib_type, " RNA-seq library"),
               group_colors = type_colors, 
               mod_name = "DynaPrism", ori_name = "Fraction-Regressed Bulk")

plot_DeltaCTSE(lib_t_CTSE_bp, lib_t_CTSE_rgr, 
               #title = paste0("BayesPrism Performance Gain"),
               subtitle = paste0(lib_prep, "-", lib_type, " RNA-seq library"),
               group_colors = type_colors, 
               mod_name = "BayesPrism", ori_name = "Fraction-Regressed Bulk")
```
# 5. Pseudobulk

```{r}
pseudobulk <- apply(true_s_exp, c(1,2), sum)
```

```{r}
#| label: pseudobulk_prism
#| eval: false
pseudobulk_Prism <- new.prism(
  reference=t(as.matrix(counts(sce))), 
  mixture=pseudobulk,
  input.type="count.matrix", 
  cell.type.labels = sce$cellType_broad_hc, 
  cell.state.labels = sce$cellType_hc,
  key = NULL,
  outlier.cut=0.01,
    outlier.fraction=0.1,
)
save(pseudobulk_Prism, file=paste0(data_dir, "NotebookRData/DynaPrism/", "pseudobulk_Prism.rdata"))
```

```{r}
#| label: load_pseudobulk_prism
load(paste0(data_dir, "NotebookRData/DynaPrism/", "pseudobulk_Prism.rdata"))
```

```{r}
#| label: pseudobulk_bp
#| eval: false
bp_pseudobulk <- run.prism(prism = pseudobulk_Prism, n.cores=14)
save(bp_pseudobulk, file=paste0(data_dir, "NotebookRData/DynaPrism/", "bp_pseudobulk.rdata"))
```

```{r}
#| label: load_pseudobulk_bp
load(paste0(data_dir, "NotebookRData/DynaPrism/", "bp_pseudobulk.rdata"))
```

```{r}
#| label: pseudobulk_dp
#| eval: false
dp_pseudobulk <- run.prism.Omega(prism = pseudobulk_Prism, Omega = Omega, n.cores=14)
save(dp_pseudobulk, file=paste0(data_dir, "NotebookRData/DynaPrism/", "dp_pseudobulk.rdata"))
```

```{r}
#| label: load_pseudobulk_dp
load(paste0(data_dir, "NotebookRData/DynaPrism/", "dp_pseudobulk.rdata"))
```

## 5.1 Fraction Estimates

```{r}
bp_psb_s_frac <- as.table(bp_pseudobulk@posterior.initial.cellState@theta)
dp_psb_s_frac <- as.table(dp_pseudobulk@posterior.initial.cellState@theta)

psb_s_CTSE_bp <- eval_frac(bp_psb_s_frac, true_s_frac)
psb_s_CTSE_bp <- eval_frac(dp_psb_s_frac, true_s_frac)
```

```{r}
#| label: psb_s_frac_plot

bp_psb_s_frac_df <- as.data.frame(bp_psb_s_frac)
colnames(bp_psb_s_frac_df) <- c("Sample", "cell_state", "Fraction")
bp_psb_s_frac_df$cell_state <- trimws(as.character(bp_psb_s_frac_df$cell_state))
bp_psb_s_frac_df$cell_state <- factor(bp_psb_s_frac_df$cell_state,
                                  levels = sort(unique(bp_psb_s_frac_df$cell_state)))

dp_psb_s_frac_df <- as.data.frame(dp_psb_s_frac)
colnames(dp_psb_s_frac_df) <- c("Sample", "cell_state", "Fraction")
dp_psb_s_frac_df$cell_state <- trimws(as.character(dp_psb_s_frac_df$cell_state))
dp_psb_s_frac_df$cell_state <- factor(dp_psb_s_frac_df$cell_state,
                                  levels = sort(unique(dp_psb_s_frac_df$cell_state)))

bp_psb_s_frac_df$Source <- "BayesPrism"
dp_psb_s_frac_df$Source <- paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ")")
combined_psb_s_df <- rbind(bp_psb_s_frac_df, dp_psb_s_frac_df, true_s_frac_df[,c("Sample", "cell_state", "Fraction", "Source")])

samples <- sort(as.character(unique(combined_psb_s_df$Sample)))[c(5:8)]
combined_psb_s_df <- combined_psb_s_df[combined_psb_s_df$Sample %in% samples, ]
```

```{r}
ggplot(combined_psb_s_df, mapping = aes(y = Fraction, x = Source, fill = cell_state)) +
  geom_col() +
  scale_fill_manual(values = state_colors) +
  facet_grid(Sample ~ ., scales = "free_x", space = "free_x") +
  theme_minimal() + # Use a cleaner base theme
  theme(
    # Remove y-axis text and ticks
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    # Rotate the Sample labels (strips) on the right to be horizontal
    strip.text.y = element_text(angle = 0),
    # Rotate x-axis labels if they start to overlap
    axis.text.x = element_text(angle = 45, hjust = 1),
    # Optional: adjust the spacing between facets
    panel.spacing = unit(0.1, "lines")
  )
```

```{r}
#bp_t_frac <- as.table(bp_pseudobulk@posterior.initial.cellType@theta)
bp_psb_t_frac <- as.table(bp_pseudobulk@posterior.theta_f@theta)
#dp_t_frac <- as.table(dp_pseudobulk@posterior.initial.cellType@theta)
dp_psb_t_frac <- as.table(dp_pseudobulk@posterior.theta_f@theta)

psb_t_CTSE_bp <- eval_frac(bp_psb_t_frac, true_t_frac)
psb_t_CTSE_dp <- eval_frac(dp_psb_t_frac, true_t_frac)
```

```{r}
#| label: psb_t_frac_plot

bp_psb_t_frac_df <- as.data.frame(bp_psb_t_frac)
colnames(bp_psb_t_frac_df) <- c("Sample", "cell_type", "Fraction")
bp_psb_t_frac_df$cell_type <- trimws(as.character(bp_psb_t_frac_df$cell_type))
bp_psb_t_frac_df$cell_type <- factor(bp_psb_t_frac_df$cell_type,
                                  levels = sort(unique(bp_psb_t_frac_df$cell_type)))

dp_psb_t_frac_df <- as.data.frame(dp_psb_t_frac)
colnames(dp_psb_t_frac_df) <- c("Sample", "cell_type", "Fraction")
dp_psb_t_frac_df$cell_type <- trimws(as.character(dp_psb_t_frac_df$cell_type))
dp_psb_t_frac_df$cell_type <- factor(dp_psb_t_frac_df$cell_type,
                                  levels = sort(unique(dp_psb_t_frac_df$cell_type)))

bp_psb_t_frac_df$Source <- "BayesPrism"
dp_psb_t_frac_df$Source <- paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ")")
combined_psb_t_df <- rbind(bp_psb_t_frac_df, dp_psb_t_frac_df, true_t_frac_df[,c("Sample", "cell_type", "Fraction", "Source")])

samples <- sort(as.character(unique(combined_psb_t_df$Sample)))[c(5:8)]
combined_psb_t_df <- combined_psb_t_df[combined_psb_t_df$Sample %in% samples, ]
```

```{r}
ggplot(combined_psb_t_df, mapping = aes(y = Fraction, x = Source, fill = cell_type)) +
  geom_col() +
  scale_fill_manual(values = type_colors) +
  facet_grid(Sample ~ ., scales = "free_x", space = "free_x") +
  theme_minimal() + # Use a cleaner base theme
  theme(
    # Remove y-axis text and ticks
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    # Rotate the Sample labels (strips) on the right to be horizontal
    strip.text.y = element_text(angle = 0),
    # Rotate x-axis labels if they start to overlap
    axis.text.x = element_text(angle = 45, hjust = 1),
    # Optional: adjust the spacing between facets
    panel.spacing = unit(0.1, "lines")
  )
```

## 5.2 CTSE Estimates

### 5.2.1 Cell-State

```{r}
bp_s_exp <- bp_pseudobulk@posterior.initial.cellState@Z
dp_s_exp <- dp_pseudobulk@posterior.initial.cellState@Z

psb_s_CTSE_bp <- eval_CTSE(bp_s_exp, true_s_exp, markers_list = state_marker_list)
psb_s_CTSE_dp <- eval_CTSE(dp_s_exp, true_s_exp, markers_list = state_marker_list)
```

```{r}
plot_DeltaCTSE(psb_s_CTSE_dp, psb_s_CTSE_bp, 
               title = paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ") Performance Gain over BayesPrism"),
               subtitle = "Pseudobulk",
               group_colors = state_colors, 
               mod_name = "DynaPrism", ori_name = "BayesPrism")
```

```{r}
plot_ExpSpe(psb_s_CTSE_dp, psb_s_CTSE_bp, gene_pressure, 
            title = "State-Level Expression Specificity",
            subtitle = paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ") on Pseudobulk"),
            mod_name = "DynaPrism", ori_name = "BayesPrism")
```

#### 5.2.1.1 Plain Bulk

```{r}
#| label: psb_s_exp
psb_X <- as.matrix(pseudobulk_Prism@mixture)
psb_X_cpm <- sweep(X, 1, rowSums(X), "/") * 1e6

G_names <- colnames(psb_X)
N_names <- rownames(psb_X)
K_names <- cell_states

psb_s_exp <- array(NA, 
                   dim = c(length(N_names), length(G_names), length(K_names)),
                   dimnames = list(N_names, G_names, K_names))

for(k in K_names) {
  psb_s_exp[,,k] <- psb_X
}
```

```{r}
psb_s_CTSE_blk <- eval_CTSE(psb_s_exp, true_s_exp, markers_list = state_marker_list)
```

```{r}
plot_DeltaCTSE(psb_s_CTSE_dp, psb_s_CTSE_blk, 
               title = paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ") Performance Gain over Plain Bulk"),
               subtitle =  paste0("Pseudobulk"),
               group_colors = state_colors, 
               mod_name = "DynaPrism", ori_name = "Plain Bulk")

plot_DeltaCTSE(psb_s_CTSE_bp, psb_s_CTSE_blk, 
               #title = paste0("BayesPrism Performance Gain"),
               subtitle = paste0("Pseudobulk"),
               group_colors = state_colors, 
               mod_name = "BayesPrism", ori_name = "Plain Bulk")
```

### 5.2.2 Cell-Type

```{r}
bp_t_exp <- bp_pseudobulk@posterior.initial.cellType@Z
dp_t_exp <- dp_pseudobulk@posterior.initial.cellType@Z

psb_t_CTSE_bp <- eval_CTSE(bp_t_exp, true_t_exp, markers_list = type_marker_list)
psb_t_CTSE_dp <- eval_CTSE(dp_t_exp, true_t_exp, markers_list = type_marker_list)
```

```{r}
psb_t_CTSE_bp$ExpSCorr_Summary
psb_t_CTSE_dp$ExpSCorr_Summary

psb_t_CTSE_bp$CvSpe_Summary
psb_t_CTSE_dp$CvSpe_Summary

psb_t_CTSE_bp$ExpSpe_Summary
psb_t_CTSE_dp$ExpSpe_Summary

psb_t_CTSE_bp$ExpMAE_Summary
psb_t_CTSE_dp$ExpMAE_Summary

psb_t_CTSE_bp$ExpRMSE_Summary
psb_t_CTSE_dp$ExpRMSE_Summary
```

```{r}
plot_DeltaCTSE(psb_t_CTSE_dp, psb_t_CTSE_bp, 
               title = paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ") Performance Gain over BayesPrism"),
               subtitle = "Pseudobulk",
               group_colors = type_colors, 
               mod_name = "DynaPrism", ori_name = "BayesPrism")
```

```{r}
plot_ExpSpe(psb_t_CTSE_dp, psb_t_CTSE_bp, gene_pressure, 
            title = "Type-Level Expression Specificity",
            subtitle = paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ") on Pseudobulk"),
            mod_name = "DynaPrism", ori_name = "BayesPrism")
```
#### 5.2.2.1 Plain Bulk

```{r}
#| label: psb_t_exp
psb_X <- as.matrix(pseudobulk_Prism@mixture)
psb_X_cpm <- sweep(X, 1, rowSums(X), "/") * 1e6

G_names <- colnames(psb_X)
N_names <- rownames(psb_X)
K_names <- cell_types

psb_t_exp <- array(NA, 
                   dim = c(length(N_names), length(G_names), length(K_names)),
                   dimnames = list(N_names, G_names, K_names))

for(k in K_names) {
  psb_t_exp[,,k] <- psb_X
}
```

```{r}
psb_t_CTSE_blk <- eval_CTSE(psb_t_exp, true_t_exp, markers_list = state_marker_list)
```

```{r}
plot_DeltaCTSE(psb_t_CTSE_dp, psb_t_CTSE_blk, 
               title = paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ") Performance Gain over Plain Bulk"),
               subtitle =  paste0("Pseudobulk"),
               group_colors = type_colors, 
               mod_name = "DynaPrism", ori_name = "Plain Bulk")

plot_DeltaCTSE(psb_t_CTSE_bp, psb_t_CTSE_blk, 
               #title = paste0("BayesPrism Performance Gain"),
               subtitle = paste0("Pseudobulk"),
               group_colors = type_colors, 
               mod_name = "BayesPrism", ori_name = "Plain Bulk")
```

#### 5.2.2.2 Fraction-Regressed Bulk

```{r}
common_n <- intersect(rownames(psb_X), rownames(true_t_frac))

psb_X <- psb_X[common_n, ]
theta_t <- true_t_frac[common_n, ]

psb_beta_hat_t <- solve(t(theta_t) %*% theta_t) %*% t(theta_t) %*% psb_X
psb_X_hat_t <- theta_t %*% psb_beta_hat_t

psb_mu_g <- colMeans(psb_X)

# Calculate X_regress: X_observed - X_predicted + mu_g
psb_X_regress_t <- psb_X - psb_X_hat_t
psb_X_regress_t <- sweep(psb_X_regress_t, 2, psb_mu_g, "+")
psb_X_regress_t[psb_X_regress_t < 0] <- 0

K_names <- colnames(theta_t)
G_names <- colnames(psb_X)
N_names <- rownames(psb_X)

rgr_t_psb <- array(NA,
                   dim = c(length(N_names), length(G_names), length(K_names)),
                   dimnames = list(N_names, G_names, K_names))

for(k in K_names) {
  rgr_t_psb[,,k] <- psb_X_regress_t
}
```

```{r}
psb_t_CTSE_rgr <- eval_CTSE(rgr_t_lib, true_t_exp, markers_list = state_marker_list)
```

```{r}
plot_DeltaCTSE(psb_t_CTSE_rgr, psb_t_CTSE_blk, 
               #title = paste0("BayesPrism Performance Gain"),
               subtitle = "Pseudobulk",
               group_colors = type_colors, 
               mod_name = "Fraction-Regressed Bulk", ori_name = "Plain Bulk")

plot_DeltaCTSE(psb_t_CTSE_dp, psb_t_CTSE_rgr, 
               title = paste0("DynaPrism (β = ", dp_res@control_param$gibbs.control$beta, ") Performance Gain over Fraction-Regressed Bulk"),
               subtitle = "Pseudobulk",
               group_colors = type_colors, 
               mod_name = "DynaPrism", ori_name = "Fraction-Regressed Bulk")

plot_DeltaCTSE(psb_t_CTSE_bp, psb_t_CTSE_rgr, 
               #title = paste0("BayesPrism Performance Gain"),
               subtitle = "Pseudobulk",
               group_colors = type_colors, 
               mod_name = "BayesPrism", ori_name = "Fraction-Regressed Bulk")
```
